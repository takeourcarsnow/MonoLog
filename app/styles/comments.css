/* Comments open/close animation
   Notes:
   - Animating `grid-template-rows: 1fr` -> `0fr` can be janky in some browsers
     because `fr` units are not interpolated smoothly. Switch to a max-height
     + opacity approach for consistent, organic open/close timing.
   - JavaScript will set an inline `max-height` to the element's scrollHeight
     when opening/closing so the transition is accurate for content of any size.
*/
.comments {
  /* collapsed by default */
  max-height: 0px;
  opacity: 0;
  overflow: hidden;
  transition: max-height 320ms cubic-bezier(0.4, 0, 0.2, 1), opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);
}
.comments > * {
  /* ensure inner wrapper doesn't overflow visually during the transition */
  overflow: hidden;
}
.comments.open {
  /* visible state; JS will typically set an inline max-height equal to the
     actual content height for a smooth transition. The CSS fallback max-height
     keeps things working even if JS is disabled. */
  opacity: 1;
  max-height: 800px; /* fallback - should be larger than typical comment panes */
}

.comment-box { display: grid; grid-template-columns: 1fr auto; gap: 8px; }
.input {
  width: 100%; border: 1px solid var(--border); background: var(--bg);
  color: var(--text); padding: 10px 12px; border-radius: 10px; font-size: 14px;
}
.input:focus { outline: 2px solid color-mix(in srgb, var(--primary), transparent 60%); border-color: var(--primary); }
.bio-editor {
  width: 100%; border: 1px solid var(--border); background: var(--bg);
  color: var(--text); padding: 10px 12px; border-radius: 10px; font-size: 14px;
  /* prevent the user from manually resizing the textarea (we control sizing via grid/CSS) */
  resize: none;
  /* allow internal scrolling if content overflows the configured height */
  overflow: auto;
}
.input-wrapper { position: relative; }
.input-ghost-placeholder {
  position: absolute;
  left: 12px; right: 12px; top: 50%; transform: translateY(-50%);
  pointer-events: none; color: color-mix(in srgb, var(--muted), transparent 12%);
  font-size: 14px; line-height: 1; overflow: hidden; white-space: nowrap;
}
.input-ghost-placeholder { display: flex; align-items: center; gap: 6px; }
.input-ghost-placeholder .typewriter {
  display: inline-block; max-width: 100%; overflow: hidden; text-overflow: ellipsis;
  color: color-mix(in srgb, var(--muted), transparent 8%);
}
.input-ghost-placeholder .caret {
  color: color-mix(in srgb, var(--muted), transparent 12%);
  opacity: 0.95;
  animation: blinkCaret 900ms steps(1) infinite;
  font-weight: 700;
}

@keyframes blinkCaret {
  0%, 49% { opacity: 1; }
  50%, 100% { opacity: 0; }
}

@media (prefers-reduced-motion: reduce) {
  .input-ghost-placeholder .typewriter { animation: none; border-right: none; }
}
.comment-list { display: grid; gap: 6px; }
.comment-item { font-size: 14px; }
.comment-item .author { font-weight: 700; margin-right: 6px; }

.comment-list { display: grid; gap: 10px; }
.comment-item { display: flex; gap: 10px; align-items: flex-start; padding: 8px; border-radius: 10px; background: color-mix(in srgb, var(--bg-elev), transparent 6%); border: 1px solid var(--border); }
.comment-avatar { width: 36px; height: 36px; border-radius: 10px; object-fit: cover; flex: 0 0 36px; }
.comment-body { display: block; min-width: 0; }
.comment-head { display:flex; gap:8px; align-items:center; margin-bottom:4px; }
.comment-text { 
  font-size: 14px; 
  color: var(--text);
  white-space: pre-wrap;
  overflow-wrap: anywhere;
  word-break: break-word;
}

/* Appear animation for comment items (staggered) */
.appear { opacity: 0; transform: translateY(6px) scale(.998); animation: appearIn 300ms cubic-bezier(.2,.8,.2,1) forwards; }
@keyframes appearIn { to { opacity: 1; transform: translateY(0) scale(1); } }

/* Skeleton placeholder styles */
.skeleton { background: linear-gradient(90deg, color-mix(in srgb, var(--bg-elev), transparent 8%), color-mix(in srgb, var(--bg-elev), transparent 2%)); color: transparent; pointer-events: none; }
.skeleton .comment-avatar { background: linear-gradient(180deg, color-mix(in srgb, var(--bg-elev), transparent 6%), color-mix(in srgb, var(--bg-elev), transparent 2%)); border-radius: 10px; }
.skeleton-avatar { width: 36px; height: 36px; border-radius: 10px; background: linear-gradient(180deg, color-mix(in srgb, var(--bg-elev), transparent 8%), color-mix(in srgb, var(--bg-elev), transparent 2%)); }
.skeleton-line { height: 12px; border-radius: 8px; margin-bottom: 8px; background: linear-gradient(90deg, color-mix(in srgb, var(--bg-elev), transparent 8%), color-mix(in srgb, var(--bg-elev), transparent 2%)); }
.skeleton-author { width: 110px; height: 14px; margin-right: 8px; display: inline-block; }
.skeleton-time { width: 40px; height: 12px; display: inline-block; }
.skeleton-text { width: 100%; height: 14px; }

@media (prefers-reduced-motion: reduce) {
  .appear { animation: none; opacity: 1; transform: none; }
}

.comment-box { display:flex; gap:8px; align-items:center; }
.comment-box .input { flex: 1 1 auto; border-radius: 999px; padding: 10px 14px; }
.comment-box .btn.primary { border-radius: 999px; padding: 8px 12px; }

/* Remove the strong blue outline/halo specifically for the comment input when focused.
   Keep global focus styles for other controls, but avoid the heavy highlight for this
   compact input to match the desired look. */
.comment-box .input:focus,
.comment-box .input:focus-visible {
  outline: none;
  box-shadow: none;
  /* keep a subtle border change for affordance if you want, otherwise keep base border */
  border-color: var(--border);
}

/* Confirm-once delete badge: first click enters .confirming state (tinted danger)
   second click proceeds with removal. Auto-cancels after a short timeout. */
.comment-badge.confirming {
  background: color-mix(in srgb, var(--danger), var(--bg-elev) 8%);
  border-color: color-mix(in srgb, var(--danger), transparent 72%);
  color: #fff;
  transform: scale(1.04);
  /* intentionally no glow/drop-shadow to keep the confirm visual subtle */
}
.comment-badge.confirming svg { stroke: #fff; color: #fff; filter: none; }

/* Inline post delete button confirming state: first click toggles confirming,
   second click (within timeout) proceeds. Visual matches comment confirm style. */
.delete-btn.confirming {
  /* Use a semi-opaque background-color (animatable) instead of a gradient so
     entering and exiting the confirming state can transition smoothly. */
  background-color: color-mix(in srgb, var(--danger), var(--bg-elev) 14%) !important;
  /* keep the visible label readable against the tinted background */
  color: var(--text) !important;
  /* ensure the border and background remain visible even though we globally
     suppress button backgrounds for edit/delete â€” use !important to win */
  border-color: color-mix(in srgb, var(--danger), transparent 72%) !important;
  transform: scale(1.02);
  will-change: transform, background-color, border-color, opacity;
}
.delete-btn.confirming .icon { color: var(--danger) !important; }

/* Ensure the confirming label remains visible even when the button is collapsed
   and always reads "Confirm". We visually hide the original label text and
   render a pseudo-element with the desired string so collapse/expand
   transitions won't switch back to the default label. */
.delete-btn.confirming .reveal.label {
  /* override any collapsed-state rules */
  max-width: 160px !important;
  opacity: 1 !important;
  transform: translateX(0) scale(1) !important;
  color: transparent !important; /* hide original text */
  position: relative !important;
}
.delete-btn.confirming .reveal.label::after {
  content: "Confirm";
  position: absolute;
  left: 0;
  top: 0;
  color: var(--text);
  white-space: nowrap;
  pointer-events: none;
}

.comment-badge { display:inline-grid; place-items:center; min-width:28px; height:28px; padding:6px; background:color-mix(in srgb, var(--bg-elev), transparent 20%); border-radius:8px; border:1px solid var(--border); color:var(--muted); }

.empty {
  padding: 32px 16px; text-align: center; color: var(--muted);
}