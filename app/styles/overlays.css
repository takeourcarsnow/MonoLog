/* Overlay styles */

/* Toast notifications */
.toast {
  position: fixed;
  left: 50%;
  bottom: calc(var(--tabbar-height) + 12px); /* sits above bottom tabbar */
  transform: translateX(-50%);
  background: color-mix(in srgb, var(--bg-elev), transparent 8%);
  color: var(--text);
  border: 1px solid var(--border);
  padding: 10px 16px;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.18);
  z-index: 99999; /* ensure above most UI */
  font-weight: 600;
  animation: toastIn 260ms var(--transition-mid) both;
  max-width: min(92vw, 720px); /* keep toasts readable on desktop */
  width: auto;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
}

.toast-message {
  text-transform: none; /* message casing handled in JS */
  white-space: normal; /* allow wrapping */
  overflow-wrap: anywhere;
  text-align: center;
  line-height: 1.3;
  padding: 4px 0; /* vertical padding inside pill */
}

@keyframes toastIn {
  from { opacity: 0; transform: translateX(-50%) translateY(6px) scale(.995); }
  to { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
}

@keyframes toastOut {
  from { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
  to { opacity: 0; transform: translateX(-50%) translateY(6px) scale(.98); }
}

.toast-fadeout {
  animation: toastOut 300ms var(--transition-mid) both;
}

/* Preloader splash overlay */
.preloader-overlay {
  position: fixed;
  inset: 0;
  display: grid;
  place-items: center;
  background: color-mix(in srgb, var(--bg), transparent 8%);
  z-index: 999999;
  pointer-events: auto; /* block interactions while shown */
  /* make these transitions important so the initial server-side
    `.no-transitions` rule (which uses `!important`) doesn't prevent
    the preloader from animating once the client removes that class.
    Use a longer, gentler duration so the overlay fade feels softer. */
  transition: opacity 640ms var(--transition-mid), transform 640ms var(--transition-mid) !important;
  opacity: 1;
}
.preloader-exit { opacity: 0; transform: scale(0.996) translateY(-6px); pointer-events: none; }

.preloader-inner {
  position: relative;
  display: flex; flex-direction: column; align-items: center; gap: 12px;
  background: transparent; color: var(--text);
  /* entrance: subtle lift + fade */
  animation: preloader-in 560ms var(--preloader-ease-quick) both;
}
.preloader-logo {
  display: block;
  width: 86px; height: 86px;
  color: var(--primary);
  /* combined slow spin with a tiny scale wobble for a more organic feel
     - uses a custom easing so the rotation speeds up early, then eases into the slower sweep */
  animation: preloader-spin-scale 2400ms var(--preloader-ease-smooth) infinite !important;
  position: relative;
  z-index: 2;
}
.preloader-inner::before {
  /* faint pulsing ring behind the logo for subtle emphasis */
  content: "";
  position: absolute;
  left: 50%; top: 50%; transform: translate(-50%, -50%);
  width: 120px; height: 120px; border-radius: 50%;
  background: radial-gradient(circle, color-mix(in srgb, var(--primary), transparent 88%) 0%, transparent 60%);
  opacity: .08;
  z-index: 1;
  filter: blur(6px);
  animation: preloader-pulse 2000ms var(--preloader-ease-quick) infinite;
}
.preloader-wordmark {
  font-weight: 800; letter-spacing: 0.6px; font-size: 16px; color: var(--text);
  opacity: 0;
  transform: translateY(6px);
  animation: preloader-wordmark-in 560ms var(--preloader-ease-quick) both;
  animation-delay: 220ms; /* reveal shortly after the logo */
}

/* In dark mode the preloader shows over a dark background; invert the logo so
  the SVG (which may be dark) remains visible. We target both the dataset
  based theme and the legacy `.dark` class. */
:root[data-theme="dark"] .preloader-logo img,
:root[data-theme="dark"] .preloader-logo,
.dark .preloader-logo img,
.dark .preloader-logo {
  /* invert only the logo visual. If the logo is an inline SVG or uses currentColor
    the color variables will handle it, but we include filter invert as a safe fallback. */
  filter: invert(1) hue-rotate(180deg);
}

@keyframes preloader-spin-scale {
  /* ramp: quick acceleration first 20%, then smooth mid-sweep, gentle deceleration to 360deg */
  0%   { transform: rotate(0deg)   scale(0.986); }
  12%  { transform: rotate(55deg)  scale(1.04); }
  28%  { transform: rotate(120deg) scale(1.02); }
  60%  { transform: rotate(230deg) scale(0.995); }
  88%  { transform: rotate(320deg) scale(1.002); }
  100% { transform: rotate(360deg) scale(1); }
}

@keyframes preloader-pulse {
  0%   { opacity: 0.05; transform: translate(-50%, -50%) scale(0.96); }
  35%  { opacity: 0.12; transform: translate(-50%, -50%) scale(1.08); }
  65%  { opacity: 0.10; transform: translate(-50%, -50%) scale(1.02); }
  100% { opacity: 0.05; transform: translate(-50%, -50%) scale(0.96); }
}

@keyframes preloader-in {
  from { opacity: 0; transform: translateY(10px) scale(.994); }
  40%  { opacity: 1; transform: translateY(0px) scale(1.006); }
  to   { opacity: 1; transform: translateY(0) scale(1); }
}

@keyframes preloader-wordmark-in {
  0%   { opacity: 0; transform: translateY(8px) scale(.998); }
  60%  { opacity: 0.65; transform: translateY(3px) scale(1.002); }
  100% { opacity: 0.98; transform: translateY(0) scale(1); }
}

@media (prefers-reduced-motion: reduce) {
  .preloader-logo { animation: none !important; }
  .preloader-overlay { transition: none !important; }
}

/* If the html carries .no-transitions to suppress initial animations during
   server render, explicitly opt this preloader back in. This selector is
   more specific than the generic `.no-transitions *` rule and will ensure
   the splash animates while the client hydrates. We still respect the
   user's `prefers-reduced-motion` media query above which disables animations. */
.no-transitions .preloader-logo {
  animation: preloader-spin 2400ms linear infinite !important;
}
.no-transitions .preloader-overlay {
  transition: opacity 640ms var(--transition-mid), transform 640ms var(--transition-mid) !important;
}

/* Blur content while preloader is active, then smoothly remove blur when it exits */
.app-content {
  /* ensure filter transitions are defined on the element itself so removing
     the `.preloader-active` class animates the change (otherwise the
     transition is removed at the same moment the class is removed and it
     snaps). Use a slightly longer duration for a subtle unblur. */
  transition: filter 1000ms cubic-bezier(.2,.65,.2,1);
  will-change: filter;
}

.preloader-active .app-content {
  filter: blur(var(--preloader-blur)) saturate(0.95);
  pointer-events: none; /* prevent interaction with app during preload */
}
.preloader-active body { overflow: hidden; }

/* Ensure the navigation (and header if present outside .app-content) also
   blurs while the preloader is active so they unblur in sync with the page
   content. Define the same transition on the nav/header so the removal of
   the `.preloader-active` class animates the filter change. */
.tabbar, .header {
  transition: filter 1000ms cubic-bezier(.2,.65,.2,1);
  will-change: filter;
}

.preloader-active .tabbar,
.preloader-active .header {
  filter: blur(var(--preloader-blur)) saturate(0.95);
  pointer-events: none; /* keep nav non-interactive while preloading */
}

/* When .preloader-active is removed the filter transition back to none creates the unblur effect */
@media (prefers-reduced-motion: reduce) {
  .preloader-active #app-root { filter: none !important; transition: none !important; }
}

/* Fullscreen image viewer */
.fullscreen-viewer {
  /* Ensure the viewer always covers the visible viewport (accounts for mobile UI)
     and sits above everything else. Use the small viewport unit where supported
     to avoid being shortened by browser UI (address/toolbars). */
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  height: 100svh; /* fallback-friendly modern unit for visible viewport */
  z-index: 2147483647; /* put above all other UI */
  display: flex;
  align-items: center;
  justify-content: center;
  background: black;
  pointer-events: auto;
  transition: opacity 0.15s ease;
  opacity: 0;
}

.fullscreen-viewer.fs-active {
  opacity: 1;
}
.fullscreen-viewer .fv-close {
  position: absolute;
  right: 18px;
  top: 18px;
  background: transparent;
  border: none;
  color: #fff;
  font-size: 20px;
  padding: 8px;
  cursor: pointer;
  z-index: 1;
  user-select: none;
  -webkit-user-select: none;
}
.fullscreen-viewer .fv-close:focus {
  outline: 2px solid rgba(255,255,255,0.14);
  outline-offset: 2px;
  border-radius: 6px;
}
.fullscreen-viewer .fv-inner {
  max-width: 100%;
  max-height: 100%;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0; /* no internal padding so image can use full area */
  box-sizing: border-box;
  /* respect device safe area so the close button / image doesn't collide with home indicator */
  padding-bottom: env(safe-area-inset-bottom, 0);
}
.fullscreen-viewer .fv-inner img {
  max-width: 100%;
  max-height: 100%;
}

/* When fullscreen is open, ensure the UI that usually reserves bottom space
   (tabbar) is hidden. Support fs-open placed on body/html/article by matching
   all common ancestors. Use !important to override layout rules. */
/* NOTE: .tabbar handled separately below to allow a sliding transition */

/* Also guarantee the viewer's inner padding is zero when active (covers any cascade) */
body.fs-open .fullscreen-viewer .fv-inner,
html.fs-open .fullscreen-viewer .fv-inner,
.fs-open .fullscreen-viewer .fv-inner {
  padding: 0 !important;
}

/* While fullscreen is active, avoid forcing layout variable changes (for
   example --header-height) or altering #app-root size. Those aggressive
   overrides cause the page to reflow and visible content to shift when the
   viewer opens/closes. Instead we hide UI visually (opacity/visibility)
   and disable transitions on layout containers so the overlay paints on top
   without triggering layout recalculation. */

/* (no layout variable overrides here to avoid reflow) */

/* Immediately hide all main UI when fullscreen is opened so only the
   fullscreen viewer is visible at the moment the user clicks the
   fullscreen button. This uses `fs-open` which is added synchronously
   in JavaScript before paint to lock scroll; the rule avoids transitions
   so the disappearance is instantaneous. */
body.fs-open .app-content,
body.fs-open .content,
body.fs-open .header,
body.fs-open .tabbar,
body.fs-open #app-root {
  opacity: 0 !important;
  visibility: hidden !important;
  pointer-events: none !important;
  transition: none !important;
}

/* While fullscreen is active, disable transitions on major layout regions
   so they don't animate into their new sizes while the overlay is appearing. */
html.fs-open .content,
.fs-open .content,
html.fs-open .header,
.fs-open .header {
  transition: none !important;
}

/* When a fullscreen viewer is open, ensure the underlying card thumbnails
   don't respond to pointer events or inherit transform state from shared
   image elements. This prevents interactions/visual drift in the page while
   the modal is active. */
.fs-open .card-media,
.fs-open .card-media * {
  pointer-events: none !important;
}

/* Hide the navbar when fullscreen viewer is open */

/* Tabbar slide transition: allow it to translate down and fade out when the
   fullscreen viewer activates. We base the slide on `body.fs-blur` (which is
   added on the next RAF) so the slide animates rather than disappearing
   instantly. Use translateY(120%) to ensure it's fully offscreen.
 */
.tabbar {
  transition: transform 260ms cubic-bezier(.2,.65,.2,1), opacity 220ms ease;
  transform: translateY(0);
  opacity: 1;
  will-change: transform, opacity;
}

body.fs-blur .tabbar {
  transform: translateY(120%);
  opacity: 0;
  pointer-events: none; /* keep nav non-interactive while fullscreen */
}

/* If thumbnails share any transform styles with the ImageZoom implementation,
   reset them while fullscreen is open so they remain visually static. */
.fs-open .card-media img {
  transform: none !important;
}

/* Blur background when entering fullscreen viewer.
   We apply the filter on the main layout containers (content, app-content,
   header, tabbar) and explicitly set a filter transition here. The rule is
   placed after the `.fs-open` transition-reset above and uses `!important`
   so it takes precedence for the `filter` property (filter doesn't force
   layout and is safe to animate). We also respect prefers-reduced-motion. */
body.fs-blur .app-content,
body.fs-blur .content,
body.fs-blur .header,
body.fs-blur .tabbar {
  /* default blur amount can be overridden via --fs-blur */
  filter: blur(var(--fs-blur, 6px)) saturate(0.95) !important;
  transition: filter 220ms cubic-bezier(.2,.65,.2,1) !important;
  will-change: filter;
  pointer-events: none; /* keep background non-interactive while fullscreen */
}

/* On initial removal of fullscreen the transition above will animate the unblur.
   Respect reduced motion preference. */
@media (prefers-reduced-motion: reduce) {
  body.fs-blur .app-content,
  body.fs-blur .content,
  body.fs-blur .header,
  body.fs-blur .tabbar {
    filter: none !important;
    transition: none !important;
  }
}

/* Blur background when about modal is open */
body.modal-blur .app-content,
body.modal-blur .content,
body.modal-blur .header,
body.modal-blur .tabbar {
  filter: blur(4px) saturate(0.95) !important;
  transition: filter 200ms cubic-bezier(.2,.65,.2,1) !important;
  will-change: filter;
  pointer-events: none; /* keep background non-interactive while modal is open */
}

/* Hide navbar when modal is open to prevent overlay */
body.modal-blur .tabbar {
  opacity: 0 !important;
  visibility: hidden !important;
}

/* Respect reduced motion preference for modal blur */
@media (prefers-reduced-motion: reduce) {
  body.modal-blur .app-content,
  body.modal-blur .content,
  body.modal-blur .header,
  body.modal-blur .tabbar {
    filter: none !important;
    transition: none !important;
  }
}
