/* Overlay styles */

/* Toast notifications */
.toast {
  position: fixed;
  left: 50%;
  bottom: calc(var(--tabbar-height) + 12px); /* sits above bottom tabbar */
  transform: translateX(-50%);
  background: color-mix(in srgb, var(--bg-elev), transparent 10%);
  color: var(--text);
  border: 1px solid var(--border);
  padding: 12px 18px;
  border-radius: 14px;
  box-shadow: 0 12px 32px rgba(0,0,0,0.18);
  z-index: 1000000; /* ensure above most UI */
  font-weight: 600;
  animation: toastIn 260ms var(--transition-mid) both;
  max-width: min(92vw, 720px); /* keep toasts readable on desktop */
  width: auto;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
}

.toast .toast-inner{ display:flex; gap:10px; align-items:center; }
.toast .toast-icon{ display:inline-flex; width:20px; height:20px; align-items:center; justify-content:center; color:var(--text); }
.toast .toast-message{ text-align:left; font-weight:600; }

.toast--success{ background: linear-gradient(90deg, color-mix(in srgb, #ecfdf5, transparent 40%), color-mix(in srgb, var(--success), transparent 92%)); border-color: color-mix(in srgb, var(--success), transparent 82%); color: var(--success); }
.toast--error{ background: linear-gradient(90deg, color-mix(in srgb, #fff5f5, transparent 40%), color-mix(in srgb, #ef4444, transparent 92%)); border-color: rgba(239,68,68,0.15); color: #ef4444; }
.toast--warn{ background: linear-gradient(90deg, color-mix(in srgb, #fff7ed, transparent 40%), color-mix(in srgb, #f59e0b, transparent 92%)); border-color: rgba(245,158,11,0.12); color: #b45309; }
.toast--info{ background: color-mix(in srgb, var(--bg-elev), transparent 10%); border-color: var(--border); color: var(--text); }

/* Dark mode overrides: use more muted tones and light text for better contrast */
:root[data-theme="dark"] .toast{
  /* Use a solid, light panel in dark mode so toast stands out (match light mode) */
  background: #ffffff;
  border-color: rgba(0,0,0,0.06);
  color: #0f172a; /* dark text */
}

:root[data-theme="dark"] .toast--error{
  background: #fff5f5; /* light red */
  border-color: rgba(239,68,68,0.08);
  color: #1f2937; /* dark text */
}
:root[data-theme="dark"] .toast--error .toast-icon{ color: #b91c1c; }

:root[data-theme="dark"] .toast--warn{
  background: #fffbeb; /* light amber */
  border-color: rgba(245,158,11,0.08);
  color: #1f2937;
}
:root[data-theme="dark"] .toast--warn .toast-icon{ color: #92400e; }

:root[data-theme="dark"] .toast--success{
  background: #f0fdf4; /* light green */
  border-color: rgba(5,150,105,0.08);
  color: #052e22;
}
:root[data-theme="dark"] .toast--success .toast-icon{ color: #047857; }

:root[data-theme="dark"] .toast--info{
  background: #f8fafc; /* very light gray */
  border-color: rgba(2,6,23,0.06);
  color: #0f172a;
}

/* On larger screens prefer showing toasts at the top so they aren't
   obscured by fixed header/nav bars that might overlap the bottom area. */
@media (min-width: 720px) {
  .toast {
    bottom: auto;
    top: calc(var(--header-height, 64px) + 12px);
    transform: translateX(-50%);
    max-width: min(80vw, 900px);
  }
}

.toast-message {
  text-transform: none; /* message casing handled in JS */
  white-space: normal; /* allow wrapping */
  overflow-wrap: anywhere;
  text-align: center;
  line-height: 1.3;
  padding: 4px 0; /* vertical padding inside pill */
}

@keyframes toastIn {
  from { opacity: 0; transform: translateX(-50%) translateY(6px) scale(.995); }
  to { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
}

@keyframes toastOut {
  from { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
  to { opacity: 0; transform: translateX(-50%) translateY(6px) scale(.98); }
}

.toast-fadeout {
  animation: toastOut 300ms var(--transition-mid) both;
}

/* Rate-limit notice animation */
.rate-limit-notice {
  opacity: 0;
  transform: translateY(6px) scale(.996);
  animation: rateLimitIn 360ms cubic-bezier(.2,.9,.3,1) both;
}

@keyframes rateLimitIn {
  from { opacity: 0; transform: translateY(6px) scale(.996); }
  60% { opacity: 1; transform: translateY(-2px) scale(1.008); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}

/* Auth header notice (replaces toast for auth messages) */
.auth-header-notice {
  max-width: 520px;
  margin: 8px auto 0;
  padding: 0; /* no panel padding - text integrates with header */
  border-radius: 0;
  box-shadow: none;
  display: flex;
  flex-direction: column;
  gap: 2px;
  align-items: center;
  justify-content: center;
  perspective: 900px;
}

/* Reserve space for the auth header/message block to avoid layout shifts
   when a notice appears. Match the default message height (title + subtitle)
   so toggling between the message and the notice doesn't push the form. */
.auth-header-area {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 64px; /* conservative height to contain title (20px) + subtitle (13px) + gaps */
  box-sizing: border-box;
  width: 100%;
}

@media (prefers-reduced-motion: reduce) {
  .auth-header-area, .auth-header-notice .notice-inner { animation: none !important; }
}

/* more refined 3D entrance with subtle blur and crossfade */
.auth-header-notice .notice-inner{
  display: inline-block;
  transform-origin: top center;
  will-change: transform, opacity, filter;
  animation: noticeEnter 420ms cubic-bezier(.18,.9,.35,1) both;
}

.auth-header-notice.enter .notice-inner { animation-name: noticeEnter; }
.auth-header-notice.exit .notice-inner { animation: noticeExit 420ms cubic-bezier(.18,.9,.35,1) both; }

@keyframes noticeEnter {
  0% { transform: translateZ(-8px) rotateX(-12deg) translateY(-6px); opacity: 0; filter: blur(6px) saturate(.96); }
  60% { transform: translateZ(8px) rotateX(2deg) translateY(0); opacity: .98; filter: blur(1px) saturate(1.02); }
  100% { transform: translateZ(0px) rotateX(0deg) translateY(0); opacity: 1; filter: blur(0px) saturate(1); }
}

@keyframes noticeExit {
  0% { transform: translateZ(0px) rotateX(0deg) translateY(0); opacity: 1; filter: blur(0px) saturate(1); }
  100% { transform: translateZ(0px) rotateX(8deg) translateY(6px); opacity: 0; filter: blur(5px) saturate(.9); }
}

.auth-header-notice.info .notice-title{ color: var(--text); }
.auth-header-notice.info .notice-sub{ color: var(--muted, #94a3b8); }

.auth-header-notice.error .notice-title{ color: var(--text); }
.auth-header-notice.error .notice-sub{ color: var(--muted, #94a3b8); }

.auth-header-notice.success .notice-title{ color: var(--success, #059669); }
.auth-header-notice.success .notice-sub{ color: var(--muted, #94a3b8); }

@keyframes noticeFlip{
  0% { opacity: 0; transform: rotateX(-60deg) translateY(-6px); }
  60% { opacity: 1; transform: rotateX(8deg) translateY(2px); }
  100% { opacity: 1; transform: rotateX(0deg) translateY(0); }
}

/* Icon badge next to the title (small check / warn / error) */
/* no icons for header notice by design; keep message typographic only */
.auth-header-notice .notice-title { font-size: 20px; display: block; margin-bottom: 4px; line-height: 1.15; font-weight: 700; }
.auth-header-notice .notice-sub { font-size: 13px; line-height: 1.2; opacity: .95; }


/* (Loader styles moved to AuthConfirmButton.css to avoid duplication) */

/* Preloader splash overlay */
.preloader-overlay {
  position: fixed;
  inset: 0;
  display: grid;
  place-items: center;
  background: color-mix(in srgb, var(--bg), transparent 4%);
  z-index: 999999;
  pointer-events: auto; /* block interactions while shown */
  /* Only animate opacity on the overlay itself. Avoid animating the
     overlay's transform because that shifts the whole viewport and can
     cause the splash to appear to 'jump' when scrollbars or layout
     changes occur. Move motion to the inner element instead. */
  transition: opacity 640ms var(--transition-mid);
  opacity: 1;
}
.preloader-overlay.preloader-initial {
  background: var(--bg);
}
.preloader-exit { opacity: 0; pointer-events: none; }

.preloader-inner {
  position: relative;
  display: flex; flex-direction: column; align-items: center; gap: 12px;
  background: transparent; color: var(--text);
  /* entrance: subtle lift + fade */
  animation: preloader-in 560ms var(--preloader-ease-quick) both;
  /* Keep a smooth transform/opacity transition for coordinated exit
     animation. By animating the inner element we avoid any center
     displacement caused by transforming the full overlay. */
  transition: transform 640ms var(--transition-mid), opacity 640ms var(--transition-mid);
}
.preloader-logo {
  display: block;
  width: 86px; height: 86px;
  color: var(--primary);
  /* combined slow spin with a tiny scale wobble for a more organic feel
     - uses a custom easing so the rotation speeds up early, then eases into the slower sweep */
  animation: preloader-spin-scale 2400ms var(--preloader-ease-smooth) infinite !important;
  position: relative;
  z-index: 2;
}
:root[data-theme="light"] .preloader-logo {
  filter: invert(1);
}
.preloader-inner::before {
  /* faint pulsing ring behind the logo for subtle emphasis */
  content: "";
  position: absolute;
  left: 50%; top: 50%; transform: translate(-50%, -50%);
  width: 120px; height: 120px; border-radius: 50%;
  background: radial-gradient(circle, color-mix(in srgb, var(--primary), transparent 88%) 0%, transparent 60%);
  opacity: .08;
  z-index: 1;
  filter: blur(6px);
  animation: preloader-pulse 2000ms var(--preloader-ease-quick) infinite;
}
.preloader-exit .preloader-inner {
  /* Exit animation lives on the inner element so the element stays
     visually centered while it moves slightly and fades. This prevents
     the whole overlay from shifting and eliminates the up/down jump. */
  transform: scale(0.996) translateY(-6px);
  opacity: 0;
 
}
.preloader-wordmark {
  font-weight: 800; letter-spacing: 0.6px; font-size: 16px; color: var(--text);
  opacity: 0;
  transform: translateY(6px);
  animation: preloader-wordmark-in 560ms var(--preloader-ease-quick) both;
  animation-delay: 220ms; /* reveal shortly after the logo */
}

/* In dark mode the preloader shows over a dark background; the logo now uses currentColor
  so it will automatically use the appropriate --primary color for visibility. */

@keyframes preloader-spin-scale {
  /* ramp: quick acceleration first 20%, then smooth mid-sweep, gentle deceleration to 360deg */
  0%   { transform: rotate(0deg)   scale(0.986); }
  12%  { transform: rotate(55deg)  scale(1.04); }
  28%  { transform: rotate(120deg) scale(1.02); }
  60%  { transform: rotate(230deg) scale(0.995); }
  88%  { transform: rotate(320deg) scale(1.002); }
  100% { transform: rotate(360deg) scale(1); }
}

@keyframes preloader-pulse {
  0%   { opacity: 0.05; transform: translate(-50%, -50%) scale(0.96); }
  35%  { opacity: 0.12; transform: translate(-50%, -50%) scale(1.08); }
  65%  { opacity: 0.10; transform: translate(-50%, -50%) scale(1.02); }
  100% { opacity: 0.05; transform: translate(-50%, -50%) scale(0.96); }
}

@keyframes preloader-in {
  from { opacity: 0; transform: translateY(10px) scale(.994); }
  40%  { opacity: 1; transform: translateY(0px) scale(1.006); }
  to   { opacity: 1; transform: translateY(0) scale(1); }
}

@keyframes preloader-wordmark-in {
  0%   { opacity: 0; transform: translateY(8px) scale(.998); }
  60%  { opacity: 0.65; transform: translateY(3px) scale(1.002); }
  100% { opacity: 0.98; transform: translateY(0) scale(1); }
}

@media (prefers-reduced-motion: reduce) {
  .preloader-logo { animation: none !important; }
  .preloader-overlay { transition: none !important; }
}

/* If the html carries .no-transitions to suppress initial animations during
   server render, explicitly opt this preloader back in. This selector is
   more specific than the generic `.no-transitions *` rule and will ensure
   the splash animates while the client hydrates. We still respect the
   user's `prefers-reduced-motion` media query above which disables animations. */
.no-transitions .preloader-logo {
  animation: preloader-spin 2400ms linear infinite !important;
}
.no-transitions .preloader-overlay {
  transition: opacity 640ms var(--transition-mid), transform 640ms var(--transition-mid) !important;
}

/* Content while preloader is active */
.preloader-active body { overflow: hidden; }

/* Ensure the navigation (and header if present outside .app-content) also
   blurs while the preloader is active so they unblur in sync with the page
   content. Define the same transition on the nav/header so the removal of
   the `.preloader-active` class animates the filter change. */

.preloader-active .tabbar,
.preloader-active .header {
  pointer-events: none; /* keep nav non-interactive while preloading */
}

/* Hide navbar initially, show after preloader finishes */
.tabbar {
  opacity: 0;
}
.preloader-finished .tabbar {
  opacity: 1;
}

/* When .preloader-active is removed the filter transition back to none creates the unblur effect */
@media (prefers-reduced-motion: reduce) {
  .preloader-active #app-root { filter: none !important; transition: none !important; }
}

/* Fullscreen image viewer */
.fullscreen-viewer {
  /* Ensure the viewer always covers the visible viewport (accounts for mobile UI)
     and sits above everything else. Use the small viewport unit where supported
     to avoid being shortened by browser UI (address/toolbars). */
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  height: calc(var(--viewport-height, 1vh) * 100) !important; /* use runtime-updated viewport height */
  z-index: 2147483647 !important; /* put above all other UI */
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  background: rgba(0,0,0,0.9) !important;
  pointer-events: auto !important;
  opacity: 0 !important;
  filter: blur(4px) !important;
  transition: opacity 300ms cubic-bezier(0.4, 0, 0.2, 1), filter 300ms cubic-bezier(0.4, 0, 0.2, 1) !important;
}
.fullscreen-viewer.active {
  opacity: 1 !important;
  filter: blur(0px) !important;
}
.fullscreen-viewer .fv-close {
  position: absolute;
  right: 18px;
  top: 18px;
  background: transparent;
  border: none;
  color: var(--text);
  font-size: 20px;
  padding: 8px;
  cursor: pointer;
  z-index: 1;
  user-select: none;
  -webkit-user-select: none;
}
:root[data-theme="light"] .fullscreen-viewer .fv-close {
  color: white;
}
.fullscreen-viewer .fv-close:focus {
  outline: 2px solid color-mix(in srgb, var(--primary), transparent 70%);
  outline-offset: 2px;
  border-radius: 6px;
}
.fullscreen-viewer .fv-nav {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0, 0, 0, 0.5);
  border: none;
  color: white;
  width: 48px;
  height: 48px;
  border-radius: 50%;
  cursor: pointer;
  z-index: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  user-select: none;
  -webkit-user-select: none;
  opacity: 0;
  visibility: hidden;
}
.fullscreen-viewer .fv-nav.visible {
  opacity: 1;
  visibility: visible;
}
.fullscreen-viewer .fv-nav:hover {
  background: rgba(0, 0, 0, 0.7);
}
.fullscreen-viewer .fv-nav:focus {
  outline: 2px solid color-mix(in srgb, var(--primary), transparent 70%);
  outline-offset: 2px;
}
.fullscreen-viewer .fv-prev {
  left: 18px;
}
.fullscreen-viewer .fv-next {
  right: 18px;
}

/* Touch-target and feedback for fullscreen close on touch devices */
@media (pointer: coarse) {
  .fullscreen-viewer .fv-close {
    padding: 10px !important;
    min-width: 44px !important;
    min-height: 44px !important;
    border-radius: 10px !important;
    background: transparent !important;
  }

  .fullscreen-viewer .fv-close:active {
    background: color-mix(in srgb, var(--text), transparent 94%) !important;
  }
}
.modal-overlay {
  position: fixed;
  inset: 0; /* top:0; right:0; bottom:0; left:0 */
  display: grid;
  place-items: center;
  background: rgba(0,0,0,0.48);
  z-index: 1000500; /* above most UI but below full-screen viewer/toasts */
  padding: 20px;
  box-sizing: border-box;
  pointer-events: auto;
  animation: modalFadeIn 160ms var(--transition-fast) both;
}

.modal {
  background: color-mix(in srgb, var(--bg-elev), transparent 6%);
  color: var(--text);
  border-radius: 14px;
  box-shadow: 0 18px 48px rgba(2,6,23,0.36);
  padding: 18px;
  max-width: 720px;
  width: 100%;
  box-sizing: border-box;
  border: 1px solid var(--border);
}

.delete-confirm-modal { max-width: 560px; text-align: center; display: flex; flex-direction: column; align-items: center; }

.modal h2 { margin: 0 0 8px 0; font-size: 18px; }
.modal .muted { color: var(--muted); margin: 0 0 12px 0; }

.delete-confirm-controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
.delete-confirm-controls .input { flex: 1 1 220px; min-width: 180px; padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border); background: var(--bg); color: var(--text); }
.delete-confirm-controls .btn.small { padding: 8px 10px; border-radius: 8px; }
.delete-confirm-controls .btn.small.danger { background: linear-gradient(180deg, var(--danger-bg-start), var(--danger-bg-end)); border: 1px solid var(--danger-border); color: var(--danger); }

.delete-confirm-input { margin-bottom: 12px; }
.delete-confirm-input .input { width: 100%; padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border); background: var(--bg); color: var(--text); }

.delete-confirm-buttons { display: flex; gap: 8px; justify-content: flex-end; }

.modal .error { color: var(--danger); margin-top: 10px; }

@keyframes modalFadeIn {
  from { opacity: 0; transform: translateY(6px) scale(.998); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}

@media (max-width: 520px) {
  .modal { border-radius: 12px; padding: 14px; }
  .delete-confirm-modal { width: 100%; }
}
.fullscreen-viewer .fv-inner {
  max-width: 100%;
  max-height: 100%;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0; /* no internal padding so image can use full area */
  box-sizing: border-box;
  /* respect device safe area so the close button / image doesn't collide with home indicator */
  padding-bottom: env(safe-area-inset-bottom, 0);
}
.fullscreen-viewer .fv-inner img {
  max-width: 100%;
  max-height: 100%;
  background: #000 !important;
}

/* When fullscreen is open, ensure the UI that usually reserves bottom space
   (tabbar) is hidden. Support fs-open placed on body/html/article by matching
   all common ancestors. Use !important to override layout rules. */
/* NOTE: .tabbar handled separately below to allow a sliding transition */

/* Also guarantee the viewer's inner padding is zero when active (covers any cascade) */
body.fs-open .fullscreen-viewer .fv-inner,
html.fs-open .fullscreen-viewer .fv-inner,
.fs-open .fullscreen-viewer .fv-inner {
  padding: 0 !important;
}

/* While fullscreen is active, avoid forcing layout variable changes (for
   example --header-height) or altering #app-root size. Those aggressive
   overrides cause the page to reflow and visible content to shift when the
   viewer opens/closes. Instead we hide UI visually (opacity/visibility)
   and disable transitions on layout containers so the overlay paints on top
   without triggering layout recalculation. */

/* (no layout variable overrides here to avoid reflow) */

/* Immediately hide all main UI when fullscreen is opened so only the
   fullscreen viewer is visible at the moment the user clicks the
   fullscreen button. This uses `fs-open` which is added synchronously
   in JavaScript before paint to lock scroll; the rule avoids transitions
   so the disappearance is instantaneous. */
body.fs-open .app-content,
body.fs-open .content,
body.fs-open .header,
body.fs-open .tabbar,
body.fs-open #app-root {
  filter: blur(4px) !important;
  pointer-events: none !important;
  transition: filter 300ms cubic-bezier(0.4, 0, 0.2, 1) !important;
}

/* Ensure black background is applied immediately when fullscreen opens */
body.fs-open {
  background: transparent !important;
}

/* While fullscreen is active, disable transitions on major layout regions
   so they don't animate into their new sizes while the overlay is appearing. */
html.fs-open .content,
.fs-open .content,
html.fs-open .header,
.fs-open .header {
  transition: none !important;
}

/* When a fullscreen viewer is open, ensure the underlying card thumbnails
   don't respond to pointer events or inherit transform state from shared
   image elements. This prevents interactions/visual drift in the page while
   the modal is active. */
.fs-open .card-media,
.fs-open .card-media * {
  pointer-events: none !important;
}

/* Hide the navbar when fullscreen viewer is open */

/* Blur background when about modal is open */
body.modal-blur .app-content,
body.modal-blur .content,
body.modal-blur .header,
body.modal-blur .tabbar {
  filter: blur(4px) !important;
  transition: filter 200ms cubic-bezier(.2,.65,.2,1) !important;
  will-change: filter;
  pointer-events: none; /* keep background non-interactive while modal is open */
}

/* Hide navbar when modal is open to prevent overlay */
body.modal-blur .tabbar {
  opacity: 0 !important;
  visibility: hidden !important;
}

/* Respect reduced motion preference for modal blur */
@media (prefers-reduced-motion: reduce) {
  body.modal-blur .app-content,
  body.modal-blur .content,
  body.modal-blur .header,
  body.modal-blur .tabbar {
    filter: none !important;
    transition: none !important;
  }
}
